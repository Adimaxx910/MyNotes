Choosing the Appropriate Status Code:
*****************************************************
 The controller action method determines the appropriate HTTP status code based on the result of the request. 
The status code indicates whether the request was successful, encountered an error, or has some other status.

For successful requests, common status codes include:
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
200 OK   :   Indicates that the request was successful, and the response contains the requested data.
201 Created  :  Typically used after a successful POST request to indicate that a new resource has been created.
204 No Content  :  Used when the request was successful, but there is no data to return in the response body (e.g., for successful DELETE requests).
For error conditions, common status codes include:
400 Bad Request   :   Indicates that the client's request was malformed or had invalid parameters.
401 Unauthorized  :  Indicates that the request requires authentication, and the client hasn't provided valid credentials.
403 Forbidden  :   Indicates that the client is not allowed to access the requested resource.
404 Not Found   :   Indicates that the requested resource was not found.
500 Internal Server Error  : Indicates that an unexpected error occurred on the server.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

>In many cases, ASP.NET Web API can automatically determine the appropriate status code based on the action method's return type and the data being returned.

>Custom Status Codes: You can also set custom status codes by creating a HttpResponseMessage object and explicitly setting the StatusCode property. For example:

example----

public HttpResponseMessage Post(Product product)
{
    // Perform validation and other operations
    if (validationFailed)
    {
        return new HttpResponseMessage(HttpStatusCode.BadRequest);        
    }

    // Other processing
    return new HttpResponseMessage(HttpStatusCode.Created);
}

_________________________________________________________________________________________________________________________________________
Headers:

HTTP headers provide additional metadata and instructions to the server. Headers are key-value pairs separated by a colon (":"). 
There are several standard headers, and clients can also include custom headers as needed.
Common headers include:

HOST                     : Specifies the domain or host to which the request is being sent.
User-Agent            : Identifies the client application or browser making the request.
Accept                     : Informs the server of the types of content the client can accept (e.g., HTML, JSON).
Cookie                     : Contains any cookies associated with the client's session.
Authorization        :  Provides authentication credentials if required.
Content-Type        : Specifies the format of the message body, if present.
Content-Length    : Indicates the size of the message body, if present.

Headers are terminated by a blank line, which signals the end of the headers section.

Example Headers:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Host: www.example.com
    User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
    Cookie: session_id=abc123; user_id=456
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


____________________________________________________________________________________________________________________

THE DETAILED PROCESS OF CLIENT-SERVER-CONTROLLER RELATION  
-----------------------------------------------------------------------------------------

You are correct that the response is generated by the server. 
When I mentioned that the controller generates the response, I was referring to the fact that the controller in an MVC (Model-View-Controller) 
architecture is responsible for orchestrating the process of generating the response on the server-side. Here's a more detailed explanation:

1>  User Interaction: The user interacts with the web application by performing actions like clicking links or submitting forms.

2>  HTTP Request Generation: The user's actions trigger the generation of an HTTP request by the web browser. This request is sent to the web server.

Controller Processing:

The web server receives the HTTP request and routes it to the appropriate controller based on the URL and routing configuration.
The controller processes the request, which may involve tasks like data retrieval, business logic execution, validation, and more.
The controller determines what data needs to be included in the response and how that data should be presented.
View Rendering: The controller typically uses a view template to render the response content. The view defines the structure and presentation of the response, including placeholders for dynamic data.

Response Generation: While the controller doesn't directly generate the entire HTTP response, it plays a central role in assembling the response:

The controller provides data to be included in the response, which may come from a database, API, or other sources.
The view template, often with the help of a view engine (e.g., Razor in ASP.NET MVC), merges the data provided by the controller into the template to generate the response content (e.g., HTML or JSON).
The controller also specifies HTTP response headers, such as the Content-Type, status code (e.g., 200 OK, 404 Not Found), and any other headers required for the response.
HTTP Response Generation: Once the controller has prepared the necessary data and provided instructions on how to generate the response, the web server takes over the task of creating the full HTTP response.

The server combines the response content generated by the view with the HTTP headers specified by the controller.
The complete HTTP response is then sent back to the user's browser.
Browser Rendering: The user's browser receives the HTTP response and renders the web page or processes the data as instructed by the server's response.

In summary, the controller's role is to coordinate and manage the various components involved in generating an HTTP response on the server. While the controller provides data and instructions, the actual response is assembled and sent by the web server based on those instructions. This separation of responsibilities helps keep the code organized and follows the principles of the MVC pattern, where each component has a distinct role.
_______________________________________________________________________________________________________________________________________________________

                                                                                                                     ADO.NET:
                                                                                    ************************************************
Manual Mapping: In ADO.NET, you manually write code to interact with the database.
 You typically use SQL queries or stored procedures to retrieve, update, insert, and delete data from the database.

No Automatic Mapping: ADO.NET does not provide automatic mapping between database tables and model classes.
 You have to write code to explicitly map the columns retrieved from the database to the properties of your model objects.

Example:

Let's say you have a Product model class with properties ProductId, Name, and Price. 
When you retrieve data from the database using ADO.NET, you would need to manually map the columns returned by your SQL query to the properties of the Product object.

csharp
Copy code
using (SqlConnection connection = new SqlConnection(connectionString))
{
    connection.Open();
    using (SqlCommand command = new SqlCommand("SELECT ProductId, Name, Price FROM Products", connection))
    {
        using (SqlDataReader reader = command.ExecuteReader())
        {
            while (reader.Read())
            {
                Product product = new Product
                {
                    ProductId = reader.GetInt32(0),
                    Name = reader.GetString(1),
                    Price = reader.GetDecimal(2)
                };
                // Add 'product' to a collection or perform other operations
            }
        }
    }
}

                                                                                                                              Entity Framework:
                                                                                                           ******************************************
Automatic Mapping: Entity Framework provides automatic mapping between database tables and model classes.
 It uses conventions or configuration to infer the mapping between model properties and database columns. By default, property names match column names.

Code-First Approach: With Entity Framework's Code-First approach, you define your model classes first and then generate the database schema from those classes. 
The framework generates the necessary database tables based on your model classes.

Database Migration: Entity Framework also supports database migration, which means that as you make changes to your model classes (add, remove, or modify properties), 
Entity Framework can automatically generate SQL scripts to update the database schema to match the new model.
..............................................................................
Example:

Suppose you have an Product model class with properties ProductId, Name, and Price. With Entity Framework's Code-First approach, you define the model class, and Entity Framework generates the corresponding database table for you.

csharp
Copy code
public class Product
{
    public int ProductId  { get; set; }
    public string Name   { get; set; }
    public decimal Price  { get; set; }
}
...................................................................................
Entity Framework will automatically create a database table named "Products" with columns corresponding to the properties ProductId, Name, and Price.

 
                                                                                                                                      **              ****                  **
                                                      
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

                                 In summary, in ADO.NET, you manually map database columns to model properties, while in Entity Framework, 
                 the mapping is automatic based on conventions or configurations. Entity Framework's Code-First approach allows you to define your models first, 
                    and the framework generates the database schema to match your models, making it easier to work with databases in an object-oriented way.

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

                                                                                                  REQUEST AND RESPONSE HEADERS 
                                                                                  _____________________________________________________

  Yes, it's possible to change or update request and response header properties, such as Content-Type, Authorization, Content-Type, Accept, and Cookie, when working with HTTP requests and responses in an ASP.NET Web API or any other web application. You can manipulate these headers using the HttpRequestMessage (for requests) and HttpResponseMessage (for responses) objects.

Here are examples of how to modify these headers:

1. Modifying Request Headers:

You can modify request headers before sending an HTTP request. For example, to set a custom Authorization header and Content-Type for a POST request:

csharp
Copy code
using System.Net.Http;
using System.Net.Http.Headers;

// Create an HttpClient
using (HttpClient client = new HttpClient())
{
    // Set the Authorization header
    client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", "your-access-token");

    // Create a request message with a specific content type
    HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Post, "https://example.com/api/resource");
    request.Content = new StringContent("Your request data");
    request.Content.Headers.ContentType = new MediaTypeHeaderValue("application/json"); // Set Content-Type

    // Send the request
    HttpResponseMessage response = await client.SendAsync(request);

    // Process the response...
}
2. Modifying Response Headers:

You can modify response headers before sending the response to the client. In an ASP.NET Web API controller action, you can set headers using the HttpResponseMessage object:

csharp
Copy code
using System.Net;
using System.Net.Http;
using System.Web.Http;

public class MyController : ApiController
{
    public IHttpActionResult Get()
    {
        // Create an HttpResponseMessage
        HttpResponseMessage response = new HttpResponseMessage(HttpStatusCode.OK);

        // Set a custom header (e.g., Cookie)
        response.Headers.Add("Set-Cookie", "my-cookie=value");

        // Set Content-Type
        response.Content = new StringContent("Response content");
        response.Content.Headers.ContentType = new MediaTypeHeaderValue("application/json");

        // Return the response
        return ResponseMessage(response);
    }
}
In this example, we set the Set-Cookie and Content-Type headers in the response.

Remember that the ability to modify certain headers may be subject to security restrictions or may require
 appropriate permissions, especially when dealing with sensitive headers like Authorization. 
Always use proper authentication and authorization mechanisms to handle sensitive headers securely.
________________________________________________________________________________________________________________________________________________________
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

now give me 2. Dapper:approach with detailed explanation of each stewp[
ChatGPT
Certainly! Dapper is a micro ORM (Object-Relational Mapping) that provides a lightweight and efficient way to interact with databases. It allows you to write raw SQL queries and map the results to C# objects. Here's a detailed explanation of how to use Dapper in an ASP.NET Web API project:

Step 1: Create a New ASP.NET Web API Project
Start by creating a new ASP.NET Web API project in Visual Studio, as mentioned in the previous responses.

Step 2: Install Dapper
Install Dapper via NuGet Package Manager:

Right-click on your project in Solution Explorer.
Select "Manage NuGet Packages."
Search for "Dapper" and install the latest version.
Step 3: Define Your Model Classes
Create your model classes that represent the data you want to retrieve from the database. These classes should mirror the structure of the data you're querying. For example, let's create an "Employee" class:

csharp
Copy code
using System;

public class Employee
{
    public int EmployeeID { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public DateTime HireDate { get; set; }
}
Step 4: Configure Connection String
In your web.config file, configure the connection string to your SQL Server database, just like in the previous examples:

xml
Copy code
<connectionStrings>
    <add name="YourConnectionStringName" 
         connectionString="Data Source=YourServerName;Initial Catalog=YourDatabaseName;Integrated Security=True;"
         providerName="System.Data.SqlClient" />
</connectionStrings>
Step 5: Use Dapper in Your API Controller
Now, you can use Dapper in your API controller to execute raw SQL queries and map the results to your model classes:

csharp
Copy code
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Web.Http;
using Dapper;

public class EmployeesController : ApiController
{
    // Define the connection string
    private readonly string connectionString = System.Configuration.ConfigurationManager.ConnectionStrings["YourConnectionStringName"].ConnectionString;

    // GET api/employees
    public IHttpActionResult Get()
    {
        using (IDbConnection dbConnection = new SqlConnection(connectionString))
        {
            dbConnection.Open();
            string query = "SELECT * FROM Employees";
            var employees = dbConnection.Query<Employee>(query);
            return Ok(employees);
        }
    }

    // GET api/employees/1
    public IHttpActionResult Get(int id)
    {
        using (IDbConnection dbConnection = new SqlConnection(connectionString))
        {
            dbConnection.Open();
            string query = "SELECT * FROM Employees WHERE EmployeeID = @Id";
            var employee = dbConnection.QueryFirstOrDefault<Employee>(query, new { Id = id });
            if (employee == null)
                return NotFound();

            return Ok(employee);
        }
    }

    // POST api/employees
    public IHttpActionResult Post(Employee employee)
    {
        using (IDbConnection dbConnection = new SqlConnection(connectionString))
        {
            dbConnection.Open();
            string query = "INSERT INTO Employees (FirstName, LastName, HireDate) VALUES (@FirstName, @LastName, @HireDate)";
            dbConnection.Execute(query, employee);
            return Created(new Uri(Request.RequestUri + "/" + employee.EmployeeID), employee);
        }
    }

    // PUT api/employees/1
    public IHttpActionResult Put(int id, Employee employee)
    {
        using (IDbConnection dbConnection = new SqlConnection(connectionString))
        {
            dbConnection.Open();
            string query = "UPDATE Employees SET FirstName = @FirstName, LastName = @LastName, HireDate = @HireDate WHERE EmployeeID = @Id";
            employee.EmployeeID = id; // Set the ID in the model
            dbConnection.Execute(query, employee);
            return Ok(employee);
        }
    }

    // DELETE api/employees/1
    public IHttpActionResult Delete(int id)
    {
        using (IDbConnection dbConnection = new SqlConnection(connectionString))
        {
            dbConnection.Open();
            string query = "DELETE FROM Employees WHERE EmployeeID = @Id";
            dbConnection.Execute(query, new { Id = id });
            return Ok();
        }
    }
}
In the above code, we use Dapper to execute raw SQL queries and map the results to the Employee model class. The connection to the database is managed using IDbConnection, and we use Dapper.Query and Dapper.Execute methods to retrieve and manipulate data.

Step 6: Test Your Web API
Build and run your ASP.NET Web API project. You can use tools like Postman or write a client application to test your API endpoints.

Using Dapper in this way gives you fine-grained control over your SQL queries while still benefiting from the efficiency and simplicity of Dapper's data mapping capabilities.
_______________________________________________________________________________________________________________________________________________
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

DbSet<TEntity> in Entity Framework provides various methods and properties that allow you to query and 
manipulate data in a database table associated with the entity type TEntity. 

                                       Here are some of the commonly used methods and properties provided by DbSet<TEntity>:
                                        ********************************************************************
CRUD Operations:

Add(entity):            Adds an entity to the DbSet. It stages the entity to be inserted into the database when SaveChanges is called.
Remove(entity):    Marks an entity to be deleted from the database when SaveChanges is called.
Find(key):          Retrieves an entity by its primary key value.
SingleOrDefault(predicate):          Returns a single entity that matches the provided predicate, or null if no match is found.
FirstOrDefault(predicate):                 Returns the first entity that matches the provided predicate, or null if no match is found.
Where(predicate):            Returns a filtered list of entities based on the provided predicate.
ToList():	 Executes the query and returns a list of entities.
Load(): 	Explicitly loads related data for an entity.


Querying and Filtering:

Where(predicate): Allows you to filter entities based on a predicate.
OrderBy, OrderByDescending, ThenBy, ThenByDescending: Used for sorting entities.
Skip(count) and Take(count): Used for pagination and limiting the number of results.
Include(navigationProperty): Eager-loads related entities to avoid lazy loading.
AsNoTracking(): Returns entities without tracking changes, which can be useful for read-only operations.
Count and Existence Checks:

Count(): Returns the number of entities in the DbSet.
Any(): Checks if there are any entities in the DbSet.
State Management:

Attach(entity): Attaches an entity to the DbSet with an Unchanged state, indicating that it is an existing entity in the database.
Entry(entity): Provides access to the state and other information about an entity.

 Async Versions:
 Many of the methods mentioned above have asynchronous versions for non-blocking database operations.
 For example, 
 ToListAsync(),
 SingleOrDefaultAsync(predicate),
 SaveChangesAsync(), etc.
____________________________________________________________________________________________________________________
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

WE CAN DEfine our Routing of a website custom wise or using ATribute [Route("api/controller/MynewControllerMethod/{parameters if needed} like this...
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                   Custom Routing: 
You may need to define custom routes to match specific URL patterns. 
For example, if you want to have a route like /api/products/{category} to retrieve products by category, 
you would need to modify the routing configuration in WebApiConfig.cs.

csharp
Copy code
config.Routes.MapHttpRoute(
    name: "ProductsByCategory",
    routeTemplate: "api/products/{category}",
    defaults: new { controller = "Products", action = "GetByCategory" }
);

                                          Attribute Routing:
 If you prefer to use attribute routing, you can enable it in WebApiConfig.cs. 
Attribute routing allows you to define routes directly on controller actions using attributes.

csharp
Copy code
config.MapHttpAttributeRoutes();
***You can then use attributes like [Route] on your controller methods to specify the route templates.**
__________________________________________________________________________________________________
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
				
				API CONTROLLER FOR REGISATRATION
			            ______________________________________
public async Task<IHttpActionResult> PostAsync([FromBody] UserRegistrationTable newUser)
 {
    
        
     if (newUser == null)
     {
         return BadRequest("Invalid registration data.");
     }
     try
     {
 
         using (var db = new Models.MyDbContext())
         {
             // Check if a user with the same email or mobile number already exists
             //change the logic when not in development state
             if (db.Users.Any(u => u.MobieNumber == newUser.MobieNumber && u.EmailAddress == newUser.EmailAddress))
             {
                 return BadRequest("Mobile number or Email already exists.");
                
             }
             string verificationToken = GenerateRandomToken(12); // Generate a random 12-character token
             newUser.VerificationToken = verificationToken;

             
             // Create SendGridMessage with dynamic template ID
             var msg = new SendGridMessage();
             msg.From = new EmailAddress("prithvicv@gmail.com","Prithvi");
             
             msg.AddTo(newUser.EmailAddress);
             msg.SetTemplateId("d-39e8b10779d94a259f71df51c7416f20"); 

             // Add dynamic template data
             
             msg.SetTemplateData(new
             {
                button_link = $"https://localhost:44361/api/verify/{verificationToken}" // Variable for button link
             });

             var apiKey = ConfigurationManager.AppSettings["SendGridSettings:ApiKey"];
             var client = new SendGridClient(apiKey);

             // // Usage:
             // var htmlContent = "<strong><p>Please click the following link to verify your email address:</p>" +
             //$"\r\n<a href=\"https://localhost:44361/api/verify/{verificationToken}\">CLICK HERE</a></strong>";
             // var msg = MailHelper.CreateSingleEmail(from, to, subject, plainTextContent, htmlContent

             var response = await client.SendEmailAsync(msg);
             if (response.StatusCode == HttpStatusCode.Accepted)
             {
                 newUser.CreatedAt = DateTime.Now;
                 db.Users.Add(newUser);
                 db.SaveChanges();
                 return Ok("Registration successful. Verification email sent.");
             }
             else
             {
                 return InternalServerError(new Exception($"Email sending failed. Status Code: {response.StatusCode}"));
             }
         }
     }
     catch (DbException ex)
     {
         return InternalServerError(new Exception("Database error: " + ex.Message));
     }
     catch (SendGridException ex)
     {
         return InternalServerError(new Exception("Email sending error: " + ex.Message));
     }
     catch (Exception ex)
     {
         return InternalServerError(new Exception("Internal server error: " + ex.Message));
     }
 }
 [HttpGet]
 [Route("api/verify/{token}")]
 public IHttpActionResult VerifyEmail(string token)
 {
     try
     {
         using (var db = new Models.MyDbContext())
         {
             var user = db.Users.SingleOrDefault(u => u.VerificationToken == token);

             if (user != null)
             {     
                 // Check if the token has expired (more than 30 minutes)
                 if (DateTime.Now - user.CreatedAt > TimeSpan.FromMinutes(2))
                 {
                     // Token has expired, delete the user record
                     db.Users.Remove(user);
                     db.SaveChanges();

                     return BadRequest("Email verification token has expired.");
                 }
                 else
                 {
                     
                     // Token is still valid, confirm the email
                     user.IsEmailConfirmed = true;
                     db.SaveChanges();

                     return Ok("Email verified successfully.");
                 }    
             }
             else
             {
                 return NotFound("Invalid verification token.");
             }

         }
     }
     catch (DbException ex)
     {
         return InternalServerError(new Exception("Verification error: " + ex.Message));
     }
 }

 private IHttpActionResult NotFound(string v)
 {
     throw new NotImplementedException();
 }


 // Pseudocode for a periodic cleanup task (e.g., using a timer)
 public class TokenCleanupTask
 {
     private System.Threading.Timer _cleanupTimer;

     public TokenCleanupTask()
     {
         
         // Initialize the timer to run the cleanup method every hour
         _cleanupTimer = new System.Threading.Timer(CleanupExpiredUsers, null, 0, TimeSpan.FromHours(1).Milliseconds);
     }

     private void CleanupExpiredUsers(object state)
     {
         try
         {
             using (var db = new Models.MyDbContext())
             {
                 // Query for users with expired tokens and IsEmailConfirmed = false
                 var expiredUsers = db.Users.Where(u =>
                     !u.IsEmailConfirmed &&
                     u.CreatedAt < DateTime.Now.Subtract(TimeSpan.FromMinutes(30)))
                     .ToList();

                 // Delete user records
                 db.Users.RemoveRange(expiredUsers);
                 db.SaveChanges();
             }
         }
         
         
         catch (ArgumentNullException ex)
         {
             return (new Exception("Null exception found"+ ex.Message));
             // Handle null reference exceptions
             // Log ex.Message for debugging and monitoring
         }
        
     }
 }

____________________________________________________________________________
CORS ERROR in .net
it occurs due to diffrenet origin urls start connecting
For example,
my html login form wants to connect with api written in visual studio which is running in local server .This Cors will allow only when the the url is defined in the origin or making cors access option public.so Cors is security guard here.
To resolve the isuue first
1)install Microsoft.AspNetCore.Cors package
2)open Program.cs
3)define var MyAllowSpecificOrigins = "_myAllowSpecificOrigins";       at top
4)then add this cors policy afyter defining builder

builder.Services.AddCors(options =>                                   //added
{
    options.AddPolicy(name: MyAllowSpecificOrigins,
                      policy =>
                      {
                          policy.WithOrigins("https://localhost:44373",
                                              "http://localhost:44373").
					AllowAnyOrigin().
					AllowAnyHeader().
					AllowAnyMethod();
                    	  });
});
4)now call this cors method after useRouting and before useauthorization.
app.UseRouting();

app.UseCors(MyAllowSpecificOrigins);    

app.UseAuthorization();
__________________________________________________________________

There are two main ways to connect DTO models to a database:

Using DTOs in controller code can help to decouple the controller layer from the data access layer. This makes the code more maintainable and scalable. It also helps to make the code more readable and easier to understand.
Authentication

1.Add the necessary packages 
>sqlserver,toold,identity,identity entityframework core,jwtbearer
2.add application db context
>add service links in program.cs
                                                      add authentication and Addjwtbearer to the services.

2.Crfeate authentoication controller